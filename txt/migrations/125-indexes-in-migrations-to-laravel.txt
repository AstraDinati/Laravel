Индексы

Создание индексов
Построитель схем Laravel поддерживает несколько типов индексов. В следующем примере создается 
новый столбец email и указывается, что его значения должны быть уникальными. Чтобы создать индекс, 
мы можем связать метод unique с определением столбца:

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('users', function (Blueprint $table) {
    $table->string('email')->unique();
});
В качестве альтернативы вы можете создать индекс после определения столбца. Для этого вы должны 
вызвать метод unique построителя схемы Blueprint. Этот метод принимает имя столбца, который должен 
получить уникальный индекс:

$table->unique('email');
Вы даже можете передать массив столбцов методу индекса для создания составного индекса:

$table->index(['account_id', 'created_at']);
При создании индекса Laravel автоматически сгенерирует имя индекса на основе таблицы, имен 
столбцов и типа индекса, но вы можете передать второй аргумент методу, чтобы указать имя индекса 
самостоятельно:

$table->unique('email', 'unique_email');

Доступные типы индексов
Построитель схем Laravel содержит методы для создания каждого типа индекса, поддерживаемого 
Laravel. Каждый метод индекса принимает необязательный второй аргумент для указания имени индекса. 
Если не указано, то имя будет производным от имен таблицы и столбцов, используемых для индекса, а 
также типа индекса. Все доступные методы индекса описаны в таблице ниже:

Команда	Описание
$table->primary('id');	Добавить первичный ключ.
$table->primary(['id', 'parent_id']);	Добавить составной ключ.
$table->unique('email');	Добавить уникальный индекс.
$table->index('state');	Добавить простой индекс.
$table->fullText('body');	Добавить полнотекстовый индекс (MySQL/PostgreSQL).
$table->fullText('body')->language('english');	Добавить полнотекстовый индекс для указанного 
языка (PostgreSQL).
$table->spatialIndex('location');	Добавить пространственный индекс (кроме SQLite).

Длина индекса и MySQL / MariaDB
По умолчанию Laravel использует набор символов utf8mb4. Если вы используете версию MySQL древнее 
5.7.7 или MariaDB древнее 10.2.2, то вам может потребоваться вручную настроить длину строки по 
умолчанию, сгенерированную миграциями, чтобы MySQL мог создавать для них индексы. Вы можете 
настроить длину строки по умолчанию, вызвав метод Schema::defaultStringLength в методе boot 
поставщика App\Providers\AppServiceProvider:

use Illuminate\Support\Facades\Schema;

/**
 * Загрузка любых служб приложения.
 *
 * @return void
 */
public function boot()
{
    Schema::defaultStringLength(191);
}
Кроме того, вы можете включить опцию innodb_large_prefix для своей базы данных. Обратитесь к 
документации вашей базы данных для получения инструкций о том, как правильно включить эту опцию.


Переименование индексов
Чтобы переименовать индекс, вы можете использовать метод renameIndex построителя схемы Blueprint. 
Этот метод принимает текущее имя индекса в качестве первого аргумента и желаемое имя в качестве 
второго аргумента:

$table->renameIndex('from', 'to')
Предупреждение
Если ваше приложение использует базу данных SQLite, то вы должны установить пакет doctrine/dbal 
через менеджер пакетов Composer, прежде чем можно будет использовать метод renameIndex.


Удаление индексов
Чтобы удалить индекс, вы должны указать имя индекса. По умолчанию Laravel автоматически назначает 
имя индекса на основе имени таблицы, имени индексированного столбца и типа индекса. Вот некоторые 
примеры:

Команда	Описание
$table->dropPrimary('users_id_primary');	Удалить первичный ключ из таблицы users.
$table->dropUnique('users_email_unique');	Удалить уникальный индекс из таблицы users.
$table->dropIndex('geo_state_index');	Удалить простой индекс из таблицы geo.
$table->dropFullText('posts_body_fulltext');	Удалить полнотекстовый индекс из таблицы posts.
$table->dropSpatialIndex('geo_location_spatialindex');	Удалить пространственный индекс из таблицы 
geo (кроме SQLite).
Если вы передадите массив столбцов в метод, удаляющий индексы, то обычное имя индекса будет 
сгенерировано на основе имени таблицы, столбцов и типа индекса:

Schema::table('geo', function (Blueprint $table) {
    $table->dropIndex(['state']); // Удалить простой индекс `geo_state_index`.
});

Ограничения внешнего ключа
Laravel также поддерживает создание ограничений внешнего ключа, которые используются для 
обеспечения ссылочной целостности на уровне базы данных. Например, давайте определим столбец 
user_id в таблице posts, который ссылается на столбец id в таблице users:

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

Schema::table('posts', function (Blueprint $table) {
    $table->unsignedBigInteger('user_id');

    $table->foreign('user_id')->references('id')->on('users');
});
Поскольку этот синтаксис довольно подробный, Laravel предлагает дополнительные, более сжатые 
методы, использующие соглашения, для повышения продуктивности разработки. При использовании метода 
foreignId для создания столбца, пример выше можно переписать так:

Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained();
});
Метод foreignId создает эквивалент столбца UNSIGNED BIGINT, в то время как метод constrained будет 
использовать соглашения для определения имени таблицы и столбца, на которые ссылаются. Если имя 
вашей таблицы не соответствует соглашениям Laravel, вы можете указать имя таблицы, передав его в 
качестве аргумента методу constrained:

Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained('users');
});
Вы также можете указать желаемое действие для свойств ограничения «при удалении» и «при обновлении»:

$table->foreignId('user_id')
      ->constrained()
      ->onUpdate('cascade')
      ->onDelete('cascade');
Для этих действий также предусмотрен альтернативный синтаксис:

Метод	Описание
$table->cascadeOnUpdate();	Обновления должны выполняться каскадом.
$table->restrictOnUpdate();	Обновления должны быть ограничены.
$table->cascadeOnDelete();	Удаление должно происходить каскадом.
$table->restrictOnDelete();	Удаление должно быть ограничено.
$table->nullOnDelete();	При удалении значение внешнего ключа должно быть установлено как null.
Любые дополнительные модификаторы столбца должны быть вызваны перед методом constrained:

$table->foreignId('user_id')
      ->nullable()
      ->constrained();

Удаление внешних ключей
Чтобы удалить внешний ключ, вы можете использовать метод dropForeign, передав в качестве аргумента 
имя ограничения внешнего ключа, которое нужно удалить. Ограничения внешнего ключа используют то же 
соглашение об именах, что и индексы. Другими словами, имя ограничения внешнего ключа основано на 
имени таблицы и столбцов в ограничении, за которым следует суффикс _foreign:

$table->dropForeign('posts_user_id_foreign');
В качестве альтернативы вы можете передать массив, содержащий имя столбца, который содержит 
внешний ключ, методу dropForeign. Массив будет преобразован в имя ограничения внешнего ключа с 
использованием соглашений об именах ограничений Laravel:

$table->dropForeign(['user_id']);

Переключение ограничений внешнего ключа
Вы можете включить или отключить ограничения внешнего ключа в своих миграциях, используя следующие 
методы:

Schema::enableForeignKeyConstraints();

Schema::disableForeignKeyConstraints();

Schema::withoutForeignKeyConstraints(function () {
    // Ограничения отключены в этом замыкании ...
});
Предупреждение
SQLite по умолчанию отключает ограничения внешнего ключа. При использовании SQLite убедитесь, что 
включили поддержку внешнего ключа в вашей конфигурации базы данных, прежде чем пытаться создать их 
в ваших миграциях. Кроме того, SQLite поддерживает внешние ключи только при создании, а не при 
изменении таблиц.